# ArmFaceID-24/8/6-进度日志

## 进度总结
在 win 构建安装 Google 的 grpc 框架，以实现人脸识别终端与服务端的通信。同时将整个项目拆分成多个工程，目前有 `client` 、`server` 、`proto` 三个模块，利用 CMake 进行构建。今日的大部分工夫都花费在理解 CMake 上，认识到 CMake 确实是构建复杂工程的实用工具。
## 问题总结

### 对 `gRpc` 以及 `protobuf` 的疑惑

#### 方法 `set_allocated_xx` 的意义？
将一个已经分配好的对象赋值给一个消息字段，避免了额外的内存分配和拷贝操作。这种方式可以确保对象的所有权清晰，因为其将指针的所有权转移了。在性能关键的应用中，这种方式可以显著减少内存分配和拷贝的开销。

`set_allocated_xx` 方法的作用：
- **直接管理内存**：允许直接将一个指针赋值给消息字段，表示消息对象现在拥有了该指针的所有权。
- **避免拷贝**：避免了将数据从一个对象拷贝到另一个对象的开销。
- **内存管理的责任转移**：在调用 `set_allocated_xx` 方法后，消息对象会负责释放该指针指向的内存。

##### 使用示例

假设有一个 `Person` 消息类型，它包含一个 `Address` 子消息类型：

```proto
message Address {
  string street = 1;
  string city = 2;
}

message Person {
  string name = 1;
  Address address = 2;
}
```

```cpp
#include "person.pb.h"
#include <iostream>

int main() {
    // 创建一个 Address 对象
    Address* address = new Address();
    address->set_street("123 Main St");
    address->set_city("Hometown");

    // 创建一个 Person 对象
    Person person;
    
    // 使用 set_allocated_address 将地址对象赋值给 person
    person.set_allocated_address(address);

    // 此时 person 对象拥有 address 的所有权，不需要再手动删除 address
    std::cout << "Name: " << person.name() << std::endl;  // 空字符串，因为未设置
    std::cout << "Street: " << person.address().street() << std::endl;
    std::cout << "City: " << person.address().city() << std::endl;

    // 当 person 被销毁时，address 的内存会被自动释放
    return 0;
}
```

在这个示例中，`address` 指针被赋值给 `person` 的 `address` 字段。此时，`person` 对象拥有了 `address` 指针的所有权，当 `person` 对象被销毁时，它会自动释放 `address` 指向的内存。

##### 注意事项

- **所有权转移**：调用 `set_allocated_xx` 后，调用者不应再使用或释放该指针，因为所有权已经转移给消息对象。
- **确保指针的唯一性**：确保在调用 `set_allocated_xx` 方法前，该指针未被其他对象拥有，以避免重复释放导致的崩溃或未定义行为。

#### `grpc`、`grpcpp`、`grpc++` 三种 API 的意义？
在使用 gRPC 的头文件时，发现其分为了三个目录，其实它们的作用在对应的头文件中有相关的说明：
```c++
#ifndef GRPC_GRPC_H
#define GRPC_GRPC_H
// ...
/*! \mainpage GRPC Core
 *
 * The GRPC Core library is a low-level library designed to be wrapped by higher
 * level libraries. The top-level API is provided in grpc.h. Security related
 * functionality lives in grpc_security.h.
 */
// ...
#endif /* GRPC_GRPC_H */
```
```c++
/// \mainpage gRPC C++ API
///
/// The gRPC C++ API mainly consists of the following classes:
/// <br>
/// - grpc::Channel, which represents the connection to an endpoint. See [the
/// gRPC Concepts page](https://grpc.io/docs/what-is-grpc/core-concepts) for
/// more details. Channels are created by the factory function
/// grpc::CreateChannel.
///
/// - grpc::CompletionQueue, the producer-consumer queue used for all
/// asynchronous communication with the gRPC runtime.
///
/// - grpc::ClientContext and grpc::ServerContext, where optional configuration
/// for an RPC can be set, such as setting custom metadata to be conveyed to the
/// peer, compression settings, authentication, etc.
///
/// - grpc::Server, representing a gRPC server, created by grpc::ServerBuilder.
///
/// Streaming calls are handled with the streaming classes in
/// \ref sync_stream.h and
/// \ref async_stream.h.
///
/// Refer to the
/// [examples](https://github.com/grpc/grpc/blob/master/examples/cpp)
/// for code putting these pieces into play.

#ifndef GRPCPP_GRPCPP_H
#define GRPCPP_GRPCPP_H
// ...
#endif // GRPCPP_GRPCPP_H
```

```c++
// DEPRECATED: The headers in include/grpc++ are deprecated. Please include the
// headers in include/grpcpp instead. This header exists only for backwards
// compatibility.

#ifndef GRPCXX_GRPCXX_H
#define GRPCXX_GRPCXX_H

#include <grpcpp/grpcpp.h>

#endif  // GRPCXX_GRPCXX_H
```

### 对 `CMake` 的疑惑

#### `gRPCConfig.cmake` 似乎没有提供 `gRPC_INCLUDE_DIRS`？
我选择修改 `gRPCConfig.cmake` ...
```cmake
# added by Yusjade
get_target_property(gRPC_INCLUDE_DIRS 
gRPC::grpc INTERFACE_INCLUDE_DIRECTORIES)
```

### 编译第三方库的`mingw`版本不同，导致无法定位程序输入点

set(CMAKE_PREFIX_PATH "E:/Qt/6.5.3/mingw_64") 这个命令的意义在于告诉CMake在指定的路径下查找安装的库和包。具体来说：

作用：指定了CMake在E:/Qt/6.5.3/mingw_64目录下查找Qt安装的文件。这包括CMake模块文件、头文件、库文件等。
背景：CMake使用find_package指令来查找外部库或包（例如Qt）。当CMake运行find_package(Qt6 COMPONENTS Core Widgets REQUIRED)时，它会在CMAKE_PREFIX_PATH指定的路径下查找Qt的配置文件。
示例：对于Qt项目，这通常是Qt的安装目录，里面包含了Qt的库、头文件、cmake配置文件等。

![alt text](image.png)